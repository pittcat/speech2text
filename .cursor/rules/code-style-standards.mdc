# TypeScript/React ä»£ç é£æ ¼æ ‡å‡†

## ğŸ“ å‘½åçº¦å®š
- **ç»„ä»¶å‘½å**ï¼šä½¿ç”¨ PascalCaseï¼Œå¦‚ `TranscriptionHistory`
- **å‡½æ•°å‘½å**ï¼šä½¿ç”¨ camelCaseï¼Œå¦‚ `handleRecordAndTranscribe`
- **å˜é‡å‘½å**ï¼šä½¿ç”¨ camelCaseï¼Œå¦‚ `transcriptionResult`
- **å¸¸é‡å‘½å**ï¼šä½¿ç”¨ UPPER_SNAKE_CASEï¼Œå¦‚ `DEFAULT_PREFERENCES`
- **æ¥å£å‘½å**ï¼šä½¿ç”¨ PascalCaseï¼Œå¦‚ `TranscriptionPreferences`
- **ç±»å‹å‘½å**ï¼šä½¿ç”¨ PascalCaseï¼Œå¦‚ `AudioRecorderState`

## ğŸ”§ TypeScript æœ€ä½³å®è·µ
- **ä¸¥æ ¼ç±»å‹æ£€æŸ¥**ï¼šé¿å…ä½¿ç”¨ `any`ï¼Œä¼˜å…ˆä½¿ç”¨å…·ä½“ç±»å‹
- **æ¥å£ä¼˜äºç±»å‹åˆ«å**ï¼šå¯¹äºå¯¹è±¡å½¢çŠ¶å®šä¹‰ä½¿ç”¨ `interface`
- **æ³›å‹çº¦æŸ**ï¼šä½¿ç”¨æ³›å‹æé«˜ä»£ç å¤ç”¨æ€§ï¼Œå¦‚ `getPreferenceValues<T>()`
- **å¯é€‰å±æ€§**ï¼šæ˜ç¡®æ ‡è®°å¯é€‰å±æ€§ `property?: type`
- **è”åˆç±»å‹**ï¼šä½¿ç”¨è”åˆç±»å‹è¡¨ç¤ºå¤šç§å¯èƒ½çš„å€¼ `'idle' | 'recording' | 'processing'`

## âš›ï¸ React ç»„ä»¶é£æ ¼
- **å‡½æ•°ç»„ä»¶**ï¼šä¼˜å…ˆä½¿ç”¨å‡½æ•°ç»„ä»¶è€Œéç±»ç»„ä»¶
- **Hook ä½¿ç”¨**ï¼šéµå¾ª Hook è§„åˆ™ï¼Œä¸åœ¨å¾ªç¯æˆ–æ¡ä»¶è¯­å¥ä¸­ä½¿ç”¨
- **çŠ¶æ€ç®¡ç†**ï¼šå•ä¸€èŒè´£åŸåˆ™ï¼Œæ¯ä¸ª state å˜é‡èŒè´£æ˜ç¡®
- **äº‹ä»¶å¤„ç†**ï¼šä½¿ç”¨æè¿°æ€§çš„å¤„ç†å‡½æ•°å‘½åï¼Œå¦‚ `handleRecordingStart`

## ğŸ“¦ å¯¼å…¥å¯¼å‡ºè§„èŒƒ
```typescript
// å¤–éƒ¨åº“å¯¼å…¥æ”¾åœ¨æœ€å‰é¢
import { Form, ActionPanel, Action, Icon } from "@raycast/api";
import { useState, useEffect } from "react";

// æœ¬åœ°æ¨¡å—å¯¼å…¥
import { useAudioRecorder } from "../hooks/useAudioRecorder";
import { transcribeAudio } from "../utils/ai/transcription";
import type { TranscriptionResult } from "../types";

// å¯¼å‡ºä¼˜å…ˆä½¿ç”¨å‘½åå¯¼å‡º
export { TranscriptionHistory };
// é»˜è®¤å¯¼å‡ºç”¨äºä¸»ç»„ä»¶
export default RecordTranscription;
```

## ğŸ¨ ä»£ç æ ¼å¼åŒ–
- **ç¼©è¿›**ï¼šä½¿ç”¨ 2 ä¸ªç©ºæ ¼ç¼©è¿›
- **åˆ†å·**ï¼šè¯­å¥ç»“å°¾å¿…é¡»ä½¿ç”¨åˆ†å·
- **å¼•å·**ï¼šä¼˜å…ˆä½¿ç”¨åŒå¼•å·
- **å°¾éšé€—å·**ï¼šå¯¹è±¡å’Œæ•°ç»„çš„æœ€åä¸€é¡¹åŠ å°¾éšé€—å·
- **è¡Œé•¿åº¦**ï¼šæ¯è¡Œä¸è¶…è¿‡ 100 ä¸ªå­—ç¬¦

## ğŸ” æ³¨é‡Šè§„èŒƒ
```typescript
/**
 * è½¬å½•éŸ³é¢‘æ–‡ä»¶ä¸ºæ–‡æœ¬
 * @param audioBuffer - éŸ³é¢‘æ•°æ®ç¼“å†²åŒº
 * @param options - è½¬å½•é€‰é¡¹é…ç½®
 * @returns Promise<è½¬å½•ç»“æœ>
 */
export async function transcribeAudio(
  audioBuffer: Buffer,
  options: TranscriptionOptions
): Promise<TranscriptionResult> {
  // å…·ä½“å®ç°...
}

// å•è¡Œæ³¨é‡Šç”¨äºè§£é‡Šå¤æ‚é€»è¾‘
// TODO: ä¼˜åŒ–éŸ³é¢‘å‹ç¼©ç®—æ³•æé«˜è½¬å½•é€Ÿåº¦
```

## ğŸš¨ é”™è¯¯å¤„ç†æ¨¡å¼
```typescript
// ä½¿ç”¨ Result æ¨¡å¼å¤„ç†å¯èƒ½å¤±è´¥çš„æ“ä½œ
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// ç»Ÿä¸€çš„å¼‚æ­¥é”™è¯¯å¤„ç†
try {
  const result = await riskyOperation();
  // å¤„ç†æˆåŠŸæƒ…å†µ
} catch (error) {
  // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯
  logger.error("OperationName", "Failed to execute", { error });
  // æä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
  showToast({ style: Toast.Style.Failure, title: "æ“ä½œå¤±è´¥" });
}
```
description:
globs:
alwaysApply: false
---
