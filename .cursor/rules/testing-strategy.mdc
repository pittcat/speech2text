# æµ‹è¯•ç­–ç•¥æŒ‡å—

é’ˆå¯¹è¯­éŸ³è½¬æ–‡å­— Raycast æ‰©å±•çš„æµ‹è¯•æœ€ä½³å®è·µï¼š

## ğŸ§ª æµ‹è¯•åˆ†å±‚ç­–ç•¥
- **å•å…ƒæµ‹è¯•**ï¼šæµ‹è¯•ç‹¬ç«‹çš„å‡½æ•°å’Œå·¥å…·ç±»ï¼Œå¦‚ `[src/utils/formatting.ts](mdc:src/utils/formatting.ts)`
- **é›†æˆæµ‹è¯•**ï¼šæµ‹è¯•æ¨¡å—ä¹‹é—´çš„äº¤äº’ï¼Œå¦‚éŸ³é¢‘å½•åˆ¶ä¸è½¬å½•çš„é›†æˆ
- **ç»„ä»¶æµ‹è¯•**ï¼šæµ‹è¯• React ç»„ä»¶çš„è¡Œä¸ºå’Œæ¸²æŸ“
- **ç«¯åˆ°ç«¯æµ‹è¯•**ï¼šæµ‹è¯•å®Œæ•´çš„ç”¨æˆ·æµç¨‹

## ğŸ¯ æµ‹è¯•é‡ç‚¹é¢†åŸŸ

### éŸ³é¢‘å¤„ç†æµ‹è¯•
```typescript
// æµ‹è¯•éŸ³é¢‘æ ¼å¼è½¬æ¢
describe('Audio Processing', () => {
  test('should convert audio to correct format', () => {
    const mockAudioBuffer = generateMockAudio();
    const result = convertToPCM(mockAudioBuffer);
    
    expect(result.sampleRate).toBe(16000);
    expect(result.channels).toBe(1);
    expect(result.bitDepth).toBe(16);
  });

  test('should chunk audio data correctly', () => {
    const audioBuffer = Buffer.alloc(20000);
    const chunks = chunkAudioData(audioBuffer, 6400);
    
    expect(chunks).toHaveLength(4);
    expect(chunks[0].length).toBe(6400);
  });
});
```

### API é›†æˆæµ‹è¯•
```typescript
// æµ‹è¯•è±†åŒ… API é›†æˆ
describe('Doubao API Integration', () => {
  test('should handle successful transcription', async () => {
    const mockAudioBuffer = generateMockAudio();
    const mockPreferences = getMockPreferences();
    
    const result = await transcribeAudio(mockAudioBuffer, mockPreferences);
    
    expect(result.success).toBe(true);
    expect(result.text).toBeTruthy();
    expect(result.confidence).toBeGreaterThan(0);
  });

  test('should handle API errors gracefully', async () => {
    // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
    mockWebSocketError();
    
    const result = await transcribeAudio(mockAudioBuffer, mockPreferences);
    
    expect(result.success).toBe(false);
    expect(result.error).toBeDefined();
  });
});
```

### é…ç½®ç®¡ç†æµ‹è¯•
```typescript
// æµ‹è¯•é…ç½®æ–‡ä»¶å¤„ç†
describe('Configuration Management', () => {
  test('should load credentials from file', () => {
    mockFileSystem({
      'credentials.json': JSON.stringify({
        appKey: 'test-key',
        accessToken: 'test-token'
      })
    });

    const credentials = loadCredentials();
    expect(credentials.appKey).toBe('test-key');
  });

  test('should merge preferences correctly', () => {
    const prefs = getPreferences();
    expect(prefs.doubaoAppKey).toBeDefined();
    expect(typeof prefs.maxRecordingDuration).toBe('number');
  });
});
```

## ğŸ”§ æµ‹è¯•å·¥å…·å’Œæ¡†æ¶
- **Jest**ï¼šä½œä¸ºä¸»è¦çš„æµ‹è¯•æ¡†æ¶
- **@testing-library/react**ï¼šç”¨äº React ç»„ä»¶æµ‹è¯•
- **Mock Service Worker (MSW)**ï¼šæ¨¡æ‹Ÿ API è¯·æ±‚
- **jest-mock-extended**ï¼šåˆ›å»ºç±»å‹å®‰å…¨çš„æ¨¡æ‹Ÿå¯¹è±¡

## ğŸ­ æ¨¡æ‹Ÿï¼ˆMockingï¼‰ç­–ç•¥
```typescript
// æ¨¡æ‹Ÿ Raycast API
jest.mock('@raycast/api', () => ({
  showToast: jest.fn(),
  getPreferenceValues: jest.fn(() => mockPreferences),
  environment: {
    supportPath: '/mock/support/path'
  }
}));

// æ¨¡æ‹ŸéŸ³é¢‘å½•åˆ¶ Hook
jest.mock('../hooks/useAudioRecorder', () => ({
  useAudioRecorder: () => ({
    isRecording: false,
    startRecording: jest.fn(),
    stopRecording: jest.fn(),
    audioBuffer: null
  })
}));
```

## ğŸ“Š æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡
- **æ•´ä½“è¦†ç›–ç‡**ï¼šè‡³å°‘ 80%
- **æ ¸å¿ƒä¸šåŠ¡é€»è¾‘**ï¼š90% ä»¥ä¸Š
- **é”™è¯¯å¤„ç†ä»£ç **ï¼š100%
- **é…ç½®å’Œåˆå§‹åŒ–ä»£ç **ï¼š85% ä»¥ä¸Š

## ğŸš€ æµ‹è¯•è‡ªåŠ¨åŒ–
```json
// package.json æµ‹è¯•è„šæœ¬
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

## ğŸ” æµ‹è¯•æ•°æ®ç®¡ç†
```typescript
// æµ‹è¯•æ•°æ®å·¥å‚
export const TestDataFactory = {
  createMockAudioBuffer: (size = 1024) => Buffer.alloc(size),
  
  createMockPreferences: (): TranscriptionPreferences => ({
    doubaoAppKey: 'test-app-key',
    doubaoAccessToken: 'test-access-token',
    doubaoSecretKey: 'test-secret-key',
    maxRecordingDuration: 300,
    language: 'zh-CN'
  }),
  
  createMockTranscriptionResult: (): TranscriptionResult => ({
    text: 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•è½¬å½•ç»“æœ',
    confidence: 0.95,
    language: 'zh-CN',
    timestamp: Date.now()
  })
};
```

## ğŸ“ æµ‹è¯•æ–‡æ¡£è§„èŒƒ
- **æµ‹è¯•ç”¨ä¾‹å‘½å**ï¼šä½¿ç”¨æè¿°æ€§çš„åç§°è¯´æ˜æµ‹è¯•å†…å®¹
- **æµ‹è¯•åˆ†ç»„**ï¼šä½¿ç”¨ `describe` æŒ‰åŠŸèƒ½æ¨¡å—åˆ†ç»„
- **æ–­è¨€æ¸…æ™°**ï¼šæ¯ä¸ªæµ‹è¯•åªéªŒè¯ä¸€ä¸ªå…·ä½“è¡Œä¸º
- **é”™è¯¯åœºæ™¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–å„ç§é”™è¯¯æƒ…å†µ

## ğŸ› è°ƒè¯•å’Œæ•…éšœæ’é™¤
```typescript
// æµ‹è¯•è°ƒè¯•æŠ€å·§
describe('Debug Tests', () => {
  test('should provide detailed error information', async () => {
    try {
      await transcribeAudio(invalidAudioBuffer);
    } catch (error) {
      // è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ä¾¿äºè°ƒè¯•
      console.log('Error details:', {
        message: error.message,
        stack: error.stack,
        context: { audioBuffer: invalidAudioBuffer }
      });
      
      expect(error.message).toContain('Invalid audio format');
    }
  });
});
```

## ğŸ”„ æŒç»­é›†æˆæµ‹è¯•
- **é¢„æäº¤æ£€æŸ¥**ï¼šè¿è¡Œå•å…ƒæµ‹è¯•å’Œä»£ç è´¨é‡æ£€æŸ¥
- **CI/CD ç®¡é“**ï¼šè‡ªåŠ¨è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
- **æµ‹è¯•æŠ¥å‘Š**ï¼šç”Ÿæˆè¯¦ç»†çš„æµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
- **æ€§èƒ½æµ‹è¯•**ï¼šç›‘æ§å…³é”®æ“ä½œçš„æ€§èƒ½æŒ‡æ ‡
description:
globs:
alwaysApply: false
---
